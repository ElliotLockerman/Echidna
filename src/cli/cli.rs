
use echidna_lib::{term, bail, bailf};
use echidna_lib::config::{Config, GroupBy, TerminalApp};
use echidna_lib::generate::{Generator, DocTypes};

use std::path::PathBuf;

use clap::Parser;

/// Generate a shim app.
#[derive(Parser, Debug)]
struct Args {
    /// The terminal program to execute.
    command: String,

    /// Path to new app, including app name.
    out_path: PathBuf,

    /// all: open together. none: one per window.
    #[arg(long, default_value_t = Default::default())]
    group_open_by: GroupBy,

    /// Path to the shim binary. [default: same directory as echidna-cli]
    #[arg(long)]
    shim_path: Option<String>,

    /// Bundle Identifier. [default: Autogenerated]
    #[arg(long)]
    bundle_id: Option<String>,

    /// Overwrite existing.
    #[arg(long, short, action)]
    force: bool,

    /// Terminal app to open in. Mutually exclusive with --generic-terminal.
    #[arg(
        long,
        help = String::from("Terminal app in which to open. Supported: ")
            + term::supported_terminals_string().as_str()
    )]
    terminal: Option<String>,

    /// An unsupported terminal to (attempt) to use by sending keystrokes. Mutually exclusive with
    /// --terminal.
    #[arg(long)]
    generic_terminal: Option<String>,

    /// A custom icon for the shim app.
    #[arg(long)]
    icon: Option<PathBuf>,

    /// Support opening all text files (default). Only one --docs-* may be passed.
    #[arg(long, group = "document-type")]
    docs_text_files: bool,

    /// Support opening all documents. Only one --docs-* may be passed.
    #[arg(long, group = "document-type")]
    docs_all_docs: bool,

    /// A comma-delimited list of Uniform Type Identifiers to support opening. Only one --docs-* may be passed.
    #[arg(long, group = "document-type")]
    docs_utis: Option<String>,

    /// A comma-delimited list of extensions to support opening. Only one --docs-* may be passed.
    #[arg(long, group = "document-type")]
    docs_exts: Option<String>,
}

fn run() -> Result<(), String> {
    let args = Args::parse();

    if args.terminal.is_some() && args.generic_terminal.is_some() {
        bail!("Only one of --terminal and --generic-terminal may be passed");
    }

    let terminal = if let Some(term) = args.generic_terminal {
        TerminalApp::Generic(term.to_owned())
    } else if let Some(term) = &args.terminal {
        if !term::is_supported(term) {
            return Err(format!(
                "Terminal {} is not supported (supported terminals: {}), but you can try it with --generic-terminal", 
                term,
                term::supported_terminals_string(),
            ));
        }
        TerminalApp::Supported(term.to_owned())
    } else {
        TerminalApp::Supported("Terminal.app".to_owned())
    };

    let config = Config{
        command: args.command,
        group_open_by: args.group_open_by,
        terminal,
    };

    let doc_types = if args.docs_text_files {
        DocTypes::TextFiles
    } else if args.docs_all_docs {
        DocTypes::AllDocs
    } else if let Some(utis) = args.docs_utis {
        DocTypes::UTIs(utis.clone())
    } else if let Some(exts) = args.docs_exts {
        DocTypes::Exts(exts)
    } else {
        DocTypes::default()
    };

    let shim_path = match args.shim_path {
        Some(x) => x.into(),
        None => {
            let mut path = std::env::current_exe()
                .map_err(|e| format!("Failed to get current exe: {e}"))?;
            if !path.pop() {
                bailf!("Couldn't pop binary filename from path '{}' !?", path.display());
            }
            path.push("echidna-shim");
            path
        }
    };

    if !shim_path.exists() {
        bailf!("Couldn't find shim executable at '{}'", shim_path.display());
    }

    let mut gen = Generator::gen(
        &config,
        &doc_types,
        &shim_path,
        args.bundle_id.as_deref(),
        args.icon.as_deref(),
        args.out_path.clone()
    )?;

    gen.save(args.force).map(|_| ()) .map_err(|e| e.to_msg(&args.out_path))
}

fn main() {
    match run() {
        Ok(()) => (),
        Err(e) => {
            eprintln!("Error: {e}");
            std::process::exit(1);
        },
    }
}

